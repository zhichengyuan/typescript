# 模块化

> 前端领域中的模块化标准：ES6、commonjs、amd、umd、system、exnext

> TS中如何书写模块化语句
> 编译结果使用的是什么模块化标准

> TS中如何书写模块化语句
> 编译结果？？

# TS中如何书写模块化语句

TS中，导入导出模块，统一使用ES6的模块化标准


# 编译结果中的模块化

可配置

TS中的模块化在编译结果中：

- 如果编译结果的模块化标准是ES6：没有区别
- 如果编译结果的模块化标准是commonjs：导出的声明会变成exports的属性，默认的导出会变成exports的default属性；

# 如何在TS中书写commonjs模块化代码

导出：export = xxx
导入：import xxx = require("xxx")


# 模块解析

模块解析：应该从什么位置寻找模块

TS中，用两种模块解析策略

- classic：经典
- node：node解析策略（唯一的变化是将js替换为ts）
    - 相对路径```require("./xxx")```
    - 非相对模块```require("xxx")```

# TS中的类

>面向对象思想

基础部分，学习类的时候，仅讨论新增的语法部分

**属性**

使用属性列表来描述类中的属性

**属性的初始化检查**

```strictPropertyInitialization:true```

属性的初始化位置：

1. 构造函数中
2. 属性的默认值

**属性可以修饰为可选的**

**属性可以修饰为只读的**

访问修饰符可以控制类中的某个成员的访问权限

- public:默认的访问修饰符，公开的，所有代码均可访问
- private：私有的，只有在类中可以访问
- protected：暂时不讲

Symble

**属性简写**

如果某个属性，通过构造函数的参数传递，并且不做任何处理的赋值给该属性。可以进行简写

**访问器**

作用：用于控制属性的读取和赋值


# 泛型

有时，书写某个函数时，会丢失一些类型信息（多个位置的类型应该保持一致或有关联的信息）

泛型：是指附属于函数、类、接口、类型别名之上的类型

泛型相当于是一个类型变量，在定义时，无法预先知道具体的类型，可以用该变量来代替，只有到调用时，才能确定它的类型

很多时候，TS会智能的根据传递的参数，推导出泛型的具体类型

如果无法完成推导，并且没有传递具体的类型，默认为空对象

泛型可以设置默认值

# 在函数中使用泛型

在函数名之后写上```<泛型名称>```

# 泛型在类、接口、类型别名中的使用

直接在名称之后写上```<泛型名称>```