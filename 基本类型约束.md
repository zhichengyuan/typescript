# 基本类型约束

>TS是一个可选的静态的类型系统

# 如何进行类型约束

仅需要在需要约束的变量、函数的参数、函数的返回值位置加上```:类型```

ts在很多场景中可以完成类型推导

any:表示任意类型，对该类型，ts不进行类型检查

> 小技巧，如何区分数字字符串和数字，关键看怎么读？
> 如果按照数字朗读，则为数字；否则为字符串
 

# 源代码和编译结果的差异

编译结果没有类型约束

# 基本类型

- number:数字
- string:字符串
- boolean：布尔
- 数组
- object:对象
- null 和 undefined

null和undefined是所有其他类型的子类型，它们可以赋值给其他类型

通过```strictNullChecks:true```，可以获得更加严格的空类型检查，null和undefined只能赋值给自身。

# 其他常用类型

- 联合类型:多种类型任选其一

配合类型保护进行判断

类型保护：当某个变量进行类型判断之后，在判断的语句块中便可以确定它的确切类型，typeof可以触发类型保护。

- void类型：通常用于约束函数的返回值，表示该函数没有任何返回

- never类型:void类型：通常用于约束函数的返回值，表示该函数永远不可能结束

- 字面量类型:使用一个值进行约束

- 元组类型（Tuple）:一个固定长度的数组，并且数组中每一项的类型确定

- any类型:any类型可以绕过类型检查，因此，any类型的数据可以赋值给任意类型

# 类型别名

对已知的一些类型定义名称

```
type 类型名 = ...

```

# 函数的相关约束

函数重载：在函数实现之前，对函数调用的多种情况进行声明

可选参数：可以在某些参数名后加问好，表示该参数可以不用传递。可选参数必须在参数末尾 


# 扩展类型-枚举

> 扩展类型：类型别名、枚举、接口、类

枚举通常用于约束某个变量的取值范围

字面量和联合类型配合使用，也可以达到同样的目标

# 字面量类型的问题

- 在类型约束位置，会产生重复代码。可以使用类型别名解决该问题。
- 逻辑含义和真实的值产生了混淆，会导致当修改真实值的时候，产生大量的修改。
- 字面量类型不会进入编译结果

# 枚举

如何定义一个枚举

```
enum 枚举名{
    枚举字段1 = 值1,
    枚举字段2 = 值2,
    ...
}

```

枚举会出现在编译结果中，编译结果表现为对象。

枚举的规则：

- 枚举的值可以是字符串或数字
- 数字枚举的值会自动自增
- 被数字枚举约束的变量，可以直接赋值为数字
- 数字枚举的编译结果 和 字符串枚举有差异

最佳实践：

- 尽量不要在一个枚举中即出现字符串字段，又出现数字字段
- 使用枚举时，尽量使用枚举字段的名称，而不使用真正的值