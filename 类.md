# 深入理解类和接口  {ignore=true}

[toc]

# 类的继承


## 成员重写

重写（override）：子类中覆盖父类的成员

子类成员不能改变父类成员的类型

无论是属性还是方法，子类都可以对父类的相应成员进行重写，但重写时，需要保证类型的匹配

注意this关键字：在继承关系中，this的指向是动态调用方法时，根据具体的调用者确定this指向

super关键字：在子类的方法中，可以使用super关键字读取父类成员

## 类型匹配

鸭子辩型法

子类的对象，始终可以赋值给父类

面向对象中，这种现象叫做里历替换原则

如果需要判断一个数据的具体数字子类型，可以使用instanceof

# protected 修饰符

readonly:只读修饰符

访问权限修饰符：private public protected

protected：受保护的成员，只能在自身和子类中访问

## 单根性和传递性

单根性：每个类最多只能拥有一个父类

传递性：如果A是B的父类，并且B是C的父类，则可认为A是C的父类

# 抽象类

有时，某个类只表示一个抽象概念，主要用于提取子类共有的成员，而不能直接创建对象。该类被称为抽象类

给类前面加上```abstract```，表示该类是一个抽象类，不可以创建一个抽象类对象

## 抽象成员

父类中，可能知道有些成员是必须存在的，但是不知道该成员的值或者实现是什么，因此，需要有一种强约束，让继承该类的子类，必须要实现该成员。

**抽象类中**，可以有抽象成员，这些抽象成员必须在子类中实现

## 设计模式 - 模板模式

设计模式：面对一些常见的功能场景，有一些固定的、经过多年实践的成熟方法，这些方法被称为设计模式。

模板模式：有些方法，所有的子类实现的流程完全一致，只是流程中的某个步骤的具体实现不一致，可以将该方法提取到父类，在父类中完成整个流程的实现，遇到实现不一致的方法时，将该方法做成抽象方法

## 静态成员

静态成员是指，附着在类上的成员（属于某个构造函数的成员）

使用static修饰的成员，是静态成员

实例成员：对象成员，属于某个类的对象

静态成员：非实例成员，属于某个类   

## 静态方法中的this

实例方法中的this指的是**当前对象**

而静态方法中的this指的是**当前类**


## 设计模式 - 单例模式

单例模式：某些类的对象，在系统中最多只能有一个，为了避免开发者造成随意创建多个类对象的错误，可以使用单例模式进行强约束


# 再谈接口

接口用于约束类、对象、函数、是一个类型契约

> 有一个马戏团，马戏团中有很多动物，包括：狮子、老虎、猴子、狗，这些动物都具有共同的属性特征：名字、年龄、种类，会打招呼，它们各自有各自的技能，技能是可能通过训练改变的

> 马戏团中有以下常见的技能:

> - 火圈表演：单火圈、双火圈
> - 平衡表演：独木桥、走钢丝
> - 智慧表演：算术题、跳舞

不使用接口实现时：

- 对能力（成员函数）没有强约束力
- 容易将类型和能力耦合在一起

系统中缺少对能力的定义：----接口

面向对象领域中的接口的语义：表达了某个类是否拥有某种能力

某个类具有某种能力，其实，就是实现了某种接口

类型保护函数:通过调用该函数，会触发TS的类型保护，该函数必须返回boolean

接口和类型别名的最大区别：接口可以被类实现，而类型别名不可以

> 接口可以继承类，表示该类的所有成员都在接口中

# 索引器

```对象[值]```，使用成员表达式

在TS中，默认情况下，不对索引器（成员表达式）做严格的类型检查

使用配置```"noImplicitAny": true,```开启对隐式any的检查

隐式any：TS根据实际情况推导出的any类型

在索引器中，键的类型可以是字符串，也可以是数字

在类中，索引器书写的位置在所有成员之前

TS中索引器的作用

- 在严格的检查下，可以实现为类动态增加成员
- 可以实现动态的操作类成员

在JS中，所有的成员名本质上，都是字符串，如果使用数字作为成员名，会自动转换为字符串

在TS中，如果某个类中使用了两种类型的索引器，要求两种索引器的值类型必须匹配


# this指向约束

https://yehudakatz.com//2011/08/10/understanding-javascript-function-invocation-and-this/


## 在JS中this指向的几种情况

明确：大部分时候，this的指向取决于函数的调用方式

- 如果直接调用函数，this的指向全局对象或undfined（启用严格模式）
- 如果使用```对象、方法```调用，this指向对象本身
- 如果dom事件的处理函数，this指向事件处理对象

特殊情况：

- 箭头函数，this在函数声明时明确指向，指向函数位置的this
- 使用bind、apply、call手动绑定对象

## TS中的this

配置noImplicitThis为true，表示不允许this隐式的指向any

在TS中，允许书写函数时，手动声明该函数中的this的指向，将this作为函数的第一个参数,该参数只用于约束this，并不是真正的参数，也不会出现在编译结果中。